
---

## **File: `src/forecasting.py`**

```python
"""
Forecasting module for Ethiopia financial inclusion
"""

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error
from scipy import stats
import warnings
warnings.filterwarnings('ignore')


class FinancialInclusionForecaster:
    """Main forecasting class for financial inclusion indicators"""
    
    def __init__(self, historical_data, event_impacts=None):
        """
        Initialize forecaster with historical data
        
        Parameters:
        -----------
        historical_data : pandas.DataFrame
            Historical time series data
        event_impacts : dict, optional
            Dictionary of event impacts
        """
        self.historical_data = historical_data
        self.event_impacts = event_impacts or {}
        self.models = {}
        self.forecasts = {}
        
    def prepare_time_series(self, indicator, freq='Y'):
        """Convert sparse data to regular time series"""
        ts = self.historical_data[
            self.historical_data['indicator_code'] == indicator
        ].copy()
        
        ts['date'] = pd.to_datetime(ts['observation_date'])
        ts = ts.set_index('date').sort_index()
        
        # Resample to annual frequency
        ts_annual = ts['value_numeric'].resample(freq).mean()
        
        # Interpolate missing values
        ts_annual = ts_annual.interpolate(method='linear')
        
        return ts_annual
    
    def fit_trend_model(self, indicator, model_type='linear'):
        """Fit trend model to historical data"""
        
        ts = self.prepare_time_series(indicator)
        
        if len(ts) < 3:
            raise ValueError(f"Insufficient data points for {indicator}")
        
        # Prepare data for regression
        X = np.arange(len(ts)).reshape(-1, 1)  # Time index
        y = ts.values
        
        if model_type == 'linear':
            model = LinearRegression()
            model.fit(X, y)
            
            # Store model
            self.models[indicator] = {
                'type': 'linear',
                'model': model,
                'r_squared': model.score(X, y),
                'intercept': model.intercept_,
                'coefficient': model.coef_[0]
            }
            
        elif model_type == 'exponential':
            # Log-linear model for exponential growth
            y_log = np.log(y)
            model = LinearRegression()
            model.fit(X, y_log)
            
            self.models[indicator] = {
                'type': 'exponential',
                'model': model,
                'r_squared': model.score(X, y_log),
                'intercept': np.exp(model.intercept_),
                'growth_rate': np.exp(model.coef_[0]) - 1
            }
            
        return self.models[indicator]
    
    def forecast(self, indicator, horizon=3, include_events=True):
        """Generate forecast for given indicator"""
        
        if indicator not in self.models:
            self.fit_trend_model(indicator)
        
        model_info = self.models[indicator]
        ts = self.prepare_time_series(indicator)
        
        # Generate baseline forecast
        n_historical = len(ts)
        future_indices = np.arange(n_historical, n_historical + horizon).reshape(-1, 1)
        
        if model_info['type'] == 'linear':
            baseline_forecast = model_info['model'].predict(future_indices)
        elif model_info['type'] == 'exponential':
            log_forecast = model_info['model'].predict(future_indices)
            baseline_forecast = np.exp(log_forecast)
        
        # Apply event impacts if requested
        if include_events and indicator in self.event_impacts:
            event_impact = self.event_impacts[indicator]
            adjusted_forecast = baseline_forecast.copy()
            
            for i in range(horizon):
                # Apply event impact with decay over time
                impact = event_impact * (0.9 ** i)  # 10% decay per period
                adjusted_forecast[i] += impact
        else:
            adjusted_forecast = baseline_forecast
        
        # Calculate confidence intervals
        residuals = ts.values - model_info['model'].predict(np.arange(len(ts)).reshape(-1, 1))
        std_error = np.std(residuals)
        
        # t-value for 95% CI
        t_value = stats.t.ppf(0.975, df=len(residuals)-2)
        
        ci_width = t_value * std_error * np.sqrt(1 + 1/len(ts))
        
        lower_bound = adjusted_forecast - ci_width
        upper_bound = adjusted_forecast + ci_width
        
        # Store forecast
        self.forecasts[indicator] = {
            'baseline': baseline_forecast,
            'adjusted': adjusted_forecast,
            'lower_bound': lower_bound,
            'upper_bound': upper_bound,
            'std_error': std_error,
            'horizon': horizon
        }
        
        return self.forecasts[indicator]
    
    def generate_scenarios(self, indicator, optimistic_factor=1.2, pessimistic_factor=0.8):
        """Generate multiple scenarios"""
        
        if indicator not in self.forecasts:
            self.forecast(indicator)
        
        base_forecast = self.forecasts[indicator]['adjusted']
        
        scenarios = {
            'optimistic': base_forecast * optimistic_factor,
            'base': base_forecast,
            'pessimistic': base_forecast * pessimistic_factor
        }
        
        return scenarios
    
    def evaluate_model(self, indicator, test_years=1):
        """Evaluate model performance using time series cross-validation"""
        
        ts = self.prepare_time_series(indicator)
        
        if len(ts) <= test_years + 2:
            return None
        
        # Perform expanding window cross-validation
        errors = []
        
        for i in range(len(ts) - test_years - 1):
            # Train on first i+1 points
            train = ts.iloc[:i+1]
            test = ts.iloc[i+1:i+1+test_years]
            
            # Fit model
            X_train = np.arange(len(train)).reshape(-1, 1)
            y_train = train.values
            
            model = LinearRegression()
            model.fit(X_train, y_train)
            
            # Predict test period
            X_test = np.arange(len(train), len(train) + len(test)).reshape(-1, 1)
            y_pred = model.predict(X_test)
            
            # Calculate error
            mae = mean_absolute_error(test.values, y_pred)
            errors.append(mae)
        
        return {
            'mean_absolute_error': np.mean(errors),
            'error_std': np.std(errors),
            'n_validations': len(errors)
        }


def create_forecast_report(forecaster, indicators, output_path=None):
    """Generate comprehensive forecast report"""
    
    report_data = []
    
    for indicator in indicators:
        try:
            forecast = forecaster.forecast(indicator)
            evaluation = forecaster.evaluate_model(indicator)
            
            report_entry = {
                'indicator': indicator,
                'current_value': forecaster.prepare_time_series(indicator).iloc[-1],
                'forecast_2025': forecast['adjusted'][0],
                'forecast_2026': forecast['adjusted'][1],
                'forecast_2027': forecast['adjusted'][2],
                'uncertainty_range': forecast['upper_bound'][0] - forecast['lower_bound'][0],
                'model_r2': forecaster.models[indicator]['r_squared'] if indicator in forecaster.models else None,
                'validation_mae': evaluation['mean_absolute_error'] if evaluation else None
            }
            
            report_data.append(report_entry)
            
        except Exception as e:
            print(f"Error forecasting {indicator}: {e}")
    
    report_df = pd.DataFrame(report_data)
    
    if output_path:
        report_df.to_csv(output_path, index=False)
    
    return report_df